/**********************************************************************
  analysis_example.c:

     analysis_example.c provides examples for analyzing and 
     unitilizing Kohn-Sham Hamiltonian, overlap, and density
     matrices which are stored in filename.scfout.

  Log of analysis_example.c:

     2/July/2003  Released by T.Ozaki 

  ******************************************************************
    You can utilize a filename.scfout which is generated by the SCF
    calculation of OpenMX by the following procedure:

     1. Define your main routine as follows:

           int main(int argc, char *argv[]) 

     2. Include a header file, "read_scfout.h", in your main routine
        (if you want, also in other routines) as follows:

           #include "read_scfout.h"
  
     3. Call a function, read_scfout(), in the main routine as follows:

           read_scfout(argv);
  ******************************************************************

***********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "read_scfout.h"
#include "mpi.h"


int main(int argc, char *argv[]) 
{
  static int ct_AN,h_AN,Gh_AN,i,j,TNO1,TNO2;  
  static int spin,Rn,myid;
  static double *a;
  static FILE *fp;

  double Ebond[30],Es,Ep;

  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD, &myid);

  read_scfout(argv);

  /**********************************************************************
   Example 1:

   Print the numbers of atoms

     atomnum:   the number of atoms in the total system
     Catomnum:  the number of atoms in the central region
     Latomnum:  the number of atoms in the left lead
     Ratomnum:  the number of atoms in the right lead

     global index of atom runs
     Catomnum -> Catomnum + Latomnum -> Catomnum + Latomnum + Ratomnum
  ***********************************************************************/

  printf("atomnum=%i\n", atomnum);
  printf("Catomnum=%i\n",Catomnum);
  printf("Latomnum=%i\n",Latomnum);
  printf("Ratomnum=%i\n",Ratomnum);

  /**********************************************************************
   Example 2:

   Print the Kohn-Sham Hamiltonian matrix elements excluding the imaginary 
   part of the Hamiltonian matrix elements originated from the non-local 
   pseudopotentials.

      Hks[spin][ct_AN][h_AN][i][j]

      spin:  spin=0, real part for up-up
             spin=1, real part for down-down 
             spin=2, real part for up-down
             spin=3, imaginary part for up-down

             For SpinP_switch=0, spin=0 is taken into account.
             For SpinP_switch=1, spin=0,1 are taken into account.
             For SpinP_switch=3, spin=0,1 2,3 are taken into account.

             For SpinP_switch=0 or 1, the matrix elements are given by 

             up-up:       Hks[0]
             up-down:     Hks[2]
             down-up:     Hks[2]
             down-down:   Hks[1]

             For SpinP_switch=3, the matrix elements are given by 

             up-up:       Hks[0] + I*iHks[0] 
             up-down:     Hks[2] + I*(Hks[3]+iHks[2]) 
             down-up:     Hks[2] - I*(Hks[3]+iHks[2]) 
             down-down:   Hks[1] + I*iHks[1] 
             (see also the Example 3 shown below)

      ct_AN: global index of atoms
      h_AN   local index of neighbouring atoms for the atom ct_AN
      i:     orbital index in the atom ct_AN
      j:     orbital index in the atom h_AN

   NOTE: 

      For instance, if the basis specification of the atom ct_AN is s2p2,
      then the obital index runs in order of
                    s, s', px, py, pz, px', py', pz'

      Transformation of the local index h_AN to the global index Gh_AN
      is made as

                       Gh_AN = natn[ct_AN][h_AN];

      Also, the cell index is given by

                       Rn = ncn[ct_AN][h_AN];
      
      Each component l, m, or n (Rn = l*a + m*b + n*c) are given by
   
                       l = atv_ijk[Rn][1];
                       m = atv_ijk[Rn][2];
                       n = atv_ijk[Rn][3];
  ***********************************************************************/

  for (spin=0; spin<=SpinP_switch; spin++){
    printf("\n\nKohn-Sham Hamiltonian spin=%i\n",spin);
    for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
      TNO1 = Total_NumOrbs[ct_AN];
      for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
        Gh_AN = natn[ct_AN][h_AN];
        Rn = ncn[ct_AN][h_AN];
        TNO2 = Total_NumOrbs[Gh_AN];
        printf("global index=%i  local index=%i (global=%i, Rn=%i)\n",
                ct_AN,h_AN,Gh_AN,Rn);
        for (i=0; i<TNO1; i++){
          for (j=0; j<TNO2; j++){
            printf("%10.7f ",Hks[spin][ct_AN][h_AN][i][j]); 
	  }
          printf("\n");
	}
      }
    }
  }

  /**********************************************************************
   Example 3:

   Print the imaginary part of the Hamiltonian matrix elements originated 
   from the non-local pseudopotentials.

      iHks[spin][ct_AN][h_AN][i][j]

      spin:  spin=0, imaginary part for up-up
             spin=1, imaginary part for down-down 
             spin=2, imaginary part for up-down

             iHks is taken into account only if SpinP_switch==3
             The matrix elements are given by 

             up-up:       Hks[0] + I*iHks[0] 
             up-down:     Hks[2] + I*(Hks[3]+iHks[2]) 
             down-up:     Hks[2] - I*(Hks[3]+iHks[2]) 
             down-down:   Hks[1] + I*iHks[1] 
             (see also the Example 2 shown above)

      ct_AN: global index of atoms
      h_AN   local index of neighbouring atoms for the atom ct_AN
      i:     orbital index in the atom ct_AN
      j:     orbital index in the atom h_AN

   NOTE: 

      For instance, if the basis specification of the atom ct_AN is s2p2,
      then the obital index runs in order of
                    s, s', px, py, pz, px', py', pz'

      Transformation of the local index h_AN to the global index Gh_AN
      is made as

                       Gh_AN = natn[ct_AN][h_AN];

      Also, the cell index is given by

                       Rn = ncn[ct_AN][h_AN];
      
      Each component l, m, or n (Rn = l*a + m*b + n*c) are given by
   
                       l = atv_ijk[Rn][1];
                       m = atv_ijk[Rn][2];
                       n = atv_ijk[Rn][3];
  ***********************************************************************/

  if (SpinP_switch==3){

    for (spin=0; spin<=2; spin++){
      printf("\n\niHks: Kohn-Sham Hamiltonian spin=%i\n",spin);
      for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
	TNO1 = Total_NumOrbs[ct_AN];
	for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
	  Gh_AN = natn[ct_AN][h_AN];
	  Rn = ncn[ct_AN][h_AN];
	  TNO2 = Total_NumOrbs[Gh_AN];
	  printf("global index=%i  local index=%i (global=%i, Rn=%i)\n",
		 ct_AN,h_AN,Gh_AN,Rn);
	  for (i=0; i<TNO1; i++){
	    for (j=0; j<TNO2; j++){
	      printf("%10.7f ",iHks[spin][ct_AN][h_AN][i][j]); 
	    }
	    printf("\n");
	  }
	}
      }
    }
  }
	
  /**********************************************************************
   Example 4:

   Print overlap matrix

      OLP[ct_AN][h_AN][i][j]

      ct_AN: global index of atoms
      h_AN   local index of neighbouring atoms for the atom ct_AN
      i:     orbital index in the atom ct_AN
      j:     orbital index in the atom h_AN

   NOTE: 

      For instance, if the basis specification of the atom ct_AN is s2p2,
      then the obital index runs in order of
                    s, s', px, py, pz, px', py', pz'

      Transformation of the local index h_AN to the global index Gh_AN
      is made as

                       Gh_AN = natn[ct_AN][h_AN];

      Also, the cell index is given by

                       Rn = ncn[ct_AN][h_AN];
      
      Each component l, m, or n (Rn = l*a + m*b + n*c) are given by
   
                       l = atv_ijk[Rn][1];
                       m = atv_ijk[Rn][2];
                       n = atv_ijk[Rn][3];
  ***********************************************************************/

  printf("\n\nOverlap matrix\n");
  for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
    TNO1 = Total_NumOrbs[ct_AN];
    for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
      Gh_AN = natn[ct_AN][h_AN];
      Rn = ncn[ct_AN][h_AN];
      TNO2 = Total_NumOrbs[Gh_AN];
      printf("global index=%i  local index=%i (global=%i, Rn=%i)\n",
              ct_AN,h_AN,Gh_AN,Rn);
      for (i=0; i<TNO1; i++){
        for (j=0; j<TNO2; j++){
          printf("%10.7f ",OLP[ct_AN][h_AN][i][j]); 
        }
        printf("\n");
      }
    }
  }

  /**********************************************************************
   Example 5:

   Print the overlap matrix elements with position operators x, y, and z.

      x: OLPpo[0][0][ct_AN][h_AN][i][j]
      y: OLPpo[1][0][ct_AN][h_AN][i][j]
      z: OLPpo[2][0][ct_AN][h_AN][i][j]

      ct_AN: global index of atoms
      h_AN   local index of neighbouring atoms for the atom ct_AN
      i:     orbital index in the atom ct_AN
      j:     orbital index in the atom h_AN

   NOTE: 

      For instance, if the basis specification of the atom ct_AN is s2p2,
      then the obital index runs in order of
                    s, s', px, py, pz, px', py', pz'

      Transformation of the local index h_AN to the global index Gh_AN
      is made as

                       Gh_AN = natn[ct_AN][h_AN];

      Also, the cell index is given by

                       Rn = ncn[ct_AN][h_AN];
      
      Each component l, m, or n (Rn = l*a + m*b + n*c) are given by
   
                       l = atv_ijk[Rn][1];
                       m = atv_ijk[Rn][2];
                       n = atv_ijk[Rn][3];
  ***********************************************************************/

  printf("\n\nOverlap matrix with position operator x\n");
  for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
    TNO1 = Total_NumOrbs[ct_AN];
    for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
      Gh_AN = natn[ct_AN][h_AN];
      Rn = ncn[ct_AN][h_AN];
      TNO2 = Total_NumOrbs[Gh_AN];
      printf("global index=%i  local index=%i (global=%i, Rn=%i %i %i %i)\n",
	     ct_AN,h_AN,Gh_AN,Rn,atv_ijk[Rn][1],atv_ijk[Rn][2],atv_ijk[Rn][3]);
      for (i=0; i<TNO1; i++){
        for (j=0; j<TNO2; j++){
          printf("%10.7f ",OLPpo[0][0][ct_AN][h_AN][i][j]); 
        }
        printf("\n");
      }
    }
  }

  printf("\n\nOverlap matrix with position operator y\n");
  for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
    TNO1 = Total_NumOrbs[ct_AN];
    for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
      Gh_AN = natn[ct_AN][h_AN];
      Rn = ncn[ct_AN][h_AN];
      TNO2 = Total_NumOrbs[Gh_AN];
      printf("global index=%i  local index=%i (global=%i, Rn=%i %i %i %i)\n",
	     ct_AN,h_AN,Gh_AN,Rn,atv_ijk[Rn][1],atv_ijk[Rn][2],atv_ijk[Rn][3]);
      for (i=0; i<TNO1; i++){
        for (j=0; j<TNO2; j++){
          printf("%10.7f ",OLPpo[1][0][ct_AN][h_AN][i][j]); 
        }
        printf("\n");
      }
    }
  }

  printf("\n\nOverlap matrix with position operator z\n");
  for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
    TNO1 = Total_NumOrbs[ct_AN];
    for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
      Gh_AN = natn[ct_AN][h_AN];
      Rn = ncn[ct_AN][h_AN];
      TNO2 = Total_NumOrbs[Gh_AN];
      printf("global index=%i  local index=%i (global=%i, Rn=%i %i %i %i)\n",
	     ct_AN,h_AN,Gh_AN,Rn,atv_ijk[Rn][1],atv_ijk[Rn][2],atv_ijk[Rn][3]);
      for (i=0; i<TNO1; i++){
        for (j=0; j<TNO2; j++){
          printf("%10.7f ",OLPpo[2][0][ct_AN][h_AN][i][j]); 
        }
        printf("\n");
      }
    }
  }

  /**********************************************************************
   Example 6:

   Print overlap matrix with momentum operators px, py, and pz.

      x: OLPmo[0][ct_AN][h_AN][i][j]
      y: OLPmo[1][ct_AN][h_AN][i][j]
      z: OLPmo[2][ct_AN][h_AN][i][j]

      ct_AN: global index of atoms
      h_AN   local index of neighbouring atoms for the atom ct_AN
      i:     orbital index in the atom ct_AN
      j:     orbital index in the atom h_AN

   NOTE: 

      For instance, if the basis specification of the atom ct_AN is s2p2,
      then the obital index runs in order of
                    s, s', px, py, pz, px', py', pz'

      Transformation of the local index h_AN to the global index Gh_AN
      is made as

                       Gh_AN = natn[ct_AN][h_AN];

      Also, the cell index is given by

                       Rn = ncn[ct_AN][h_AN];
      
      Each component l, m, or n (Rn = l*a + m*b + n*c) are given by
   
                       l = atv_ijk[Rn][1];
                       m = atv_ijk[Rn][2];
                       n = atv_ijk[Rn][3];
  ***********************************************************************/

  printf("\n\nOverlap matrix with momentum operator px\n");
  for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
    TNO1 = Total_NumOrbs[ct_AN];
    for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
      Gh_AN = natn[ct_AN][h_AN];
      Rn = ncn[ct_AN][h_AN];
      TNO2 = Total_NumOrbs[Gh_AN];
      printf("global index=%i  local index=%i (global=%i, Rn=%i %i %i %i)\n",
	     ct_AN,h_AN,Gh_AN,Rn,atv_ijk[Rn][1],atv_ijk[Rn][2],atv_ijk[Rn][3]);
      for (i=0; i<TNO1; i++){
        for (j=0; j<TNO2; j++){
          printf("%10.7f ",OLPmo[0][ct_AN][h_AN][i][j]); 
        }
        printf("\n");
      }
    }
  }

  printf("\n\nOverlap matrix with momentum operator py\n");
  for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
    TNO1 = Total_NumOrbs[ct_AN];
    for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
      Gh_AN = natn[ct_AN][h_AN];
      Rn = ncn[ct_AN][h_AN];
      TNO2 = Total_NumOrbs[Gh_AN];
      printf("global index=%i  local index=%i (global=%i, Rn=%i %i %i %i)\n",
	     ct_AN,h_AN,Gh_AN,Rn,atv_ijk[Rn][1],atv_ijk[Rn][2],atv_ijk[Rn][3]);
      for (i=0; i<TNO1; i++){
        for (j=0; j<TNO2; j++){
          printf("%10.7f ",OLPmo[1][ct_AN][h_AN][i][j]); 
        }
        printf("\n");
      }
    }
  }

  printf("\n\nOverlap matrix with momentum operator pz\n");
  for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
    TNO1 = Total_NumOrbs[ct_AN];
    for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
      Gh_AN = natn[ct_AN][h_AN];
      Rn = ncn[ct_AN][h_AN];
      TNO2 = Total_NumOrbs[Gh_AN];
      printf("global index=%i  local index=%i (global=%i, Rn=%i %i %i %i)\n",
	     ct_AN,h_AN,Gh_AN,Rn,atv_ijk[Rn][1],atv_ijk[Rn][2],atv_ijk[Rn][3]);
      for (i=0; i<TNO1; i++){
        for (j=0; j<TNO2; j++){
          printf("%10.7f ",OLPmo[2][ct_AN][h_AN][i][j]); 
        }
        printf("\n");
      }
    }
  }

  /**********************************************************************
   Example 7:

   Print density matrix

      DM[spin][ct_AN][h_AN][i][j]

      spin:  spin=0, real part for up-up
             spin=1, real part for down-down 
             spin=2, real part for up-down
             spin=3, imaginary part for up-down

             For SpinP_switch=0, spin=0 is taken into account.
             For SpinP_switch=1, spin=0,1 are taken into account.
             For SpinP_switch=3, spin=0,1 2,3 are taken into account.

             For SpinP_switch=0 or 1, the matrix elements are given by 

             up-up:       DM[0]
             up-down:     DM[2]
             down-up:     DM[2]
             down-down:   DM[1]

             For SpinP_switch=3, the matrix elements are given by 

             up-up:       DM[0] + I*iDM[0] 
             up-down:     DM[2] + I*DM[3]
             down-up:     DM[2] - I*DM[3]
             down-down:   DM[1] + I*iDM[1] 
             (see also the Example 8 shown below)

      ct_AN: global index of atoms
      h_AN   local index of neighbouring atoms for the atom ct_AN
      i:     orbital index in the atom ct_AN
      j:     orbital index in the atom h_AN

   NOTE: 

      For instance, if the basis specification of the atom ct_AN is s2p2,
      then the obital index runs in order of
                    s, s', px, py, pz, px', py', pz'

      Transformation of the local index h_AN to the global index Gh_AN
      is made as

                       Gh_AN = natn[ct_AN][h_AN];

      Also, the cell index is given by

                       Rn = ncn[ct_AN][h_AN];
      
      Each component l, m, or n (Rn = l*a + m*b + n*c) are given by
   
                       l = atv_ijk[Rn][1];
                       m = atv_ijk[Rn][2];
                       n = atv_ijk[Rn][3];
  ***********************************************************************/

  for (spin=0; spin<=SpinP_switch; spin++){
    printf("\n\nDensity matrix spin=%i\n",spin);
    for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
      TNO1 = Total_NumOrbs[ct_AN];
      for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
        Gh_AN = natn[ct_AN][h_AN];
        Rn = ncn[ct_AN][h_AN];
        TNO2 = Total_NumOrbs[Gh_AN];

        printf("global index=%i  local index=%i (global=%i, Rn=%i)\n",
                ct_AN,h_AN,Gh_AN,Rn);

        for (i=0; i<TNO1; i++){
          for (j=0; j<TNO2; j++){
            printf("%10.7f ",DM[spin][ct_AN][h_AN][i][j]); 
	  }
          printf("\n");
	}
      }
    }
  }

  /**********************************************************************
   Example 8:

   Print density matrix

      iDM[spin][ct_AN][h_AN][i][j]

      spin:  spin=0, imaginary part for up-up
             spin=1, imaginary part for down-down 
             spin=2, imaginary part for up-down

             iDM is taken into account only if SpinP_switch==3
             The matrix elements are given by 

             up-up:       DM[0] + I*iDM[0] 
             up-down:     DM[2] + I*DM[3]
             down-up:     DM[2] - I*DM[3]
             down-down:   DM[1] + I*iDM[1] 
             (see also the Example 7 shown above)

      ct_AN: global index of atoms
      h_AN   local index of neighbouring atoms for the atom ct_AN
      i:     orbital index in the atom ct_AN
      j:     orbital index in the atom h_AN

   NOTE: 

      For instance, if the basis specification of the atom ct_AN is s2p2,
      then the obital index runs in order of
                    s, s', px, py, pz, px', py', pz'

      Transformation of the local index h_AN to the global index Gh_AN
      is made as

                       Gh_AN = natn[ct_AN][h_AN];

      Also, the cell index is given by

                       Rn = ncn[ct_AN][h_AN];
      
      Each component l, m, or n (Rn = l*a + m*b + n*c) are given by
   
                       l = atv_ijk[Rn][1];
                       m = atv_ijk[Rn][2];
                       n = atv_ijk[Rn][3];
  ***********************************************************************/

  for (spin=0; spin<2; spin++){
    printf("\n\nDensity matrix spin=%i\n",spin);
    for (ct_AN=1; ct_AN<=atomnum; ct_AN++){
      TNO1 = Total_NumOrbs[ct_AN];
      for (h_AN=0; h_AN<=FNAN[ct_AN]; h_AN++){
        Gh_AN = natn[ct_AN][h_AN];
        Rn = ncn[ct_AN][h_AN];
        TNO2 = Total_NumOrbs[Gh_AN];

        printf("global index=%i  local index=%i (global=%i, Rn=%i)\n",
                ct_AN,h_AN,Gh_AN,Rn);

        for (i=0; i<TNO1; i++){
          for (j=0; j<TNO2; j++){
            printf("%10.7f ",iDM[spin][ct_AN][h_AN][i][j]); 
	  }
          printf("\n");
	}
      }
    }
  }

  /* MPI_Finalize */

  MPI_Finalize(); 
  exit(0);
}
